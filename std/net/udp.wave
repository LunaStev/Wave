// This file is part of the Wave language project.
// Copyright (c) 2024-2026 Wave Foundation
// Copyright (c) 2024-2026 LunaStev and contributors
//
// This Source Code Form is subject to the terms of the
// Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file,
// You can obtain one at https://mozilla.org/MPL/2.0/.
//
// SPDX-License-Identifier: MPL-2.0

// =======================================================
// UDP networking for Wave
// =======================================================
//
// Datagram-based UDP API built on top of
// std::sys::linux::socket
//
// No connection abstraction.
// No async.
// No buffering.
// =======================================================

import("std::sys::linux::socket");
import("std::sys::linux::fs");


// -----------------------
// IPv4 address
// -----------------------

struct UdpAddr {
    ip: i32;     // network byte order
    port: i16;   // network byte order
}


// sockaddr_in (internal use)
struct SockAddrIn {
    family: i16;        // AF_INET
    port: i16;
    addr: i32;
    zero: array<u8, 8>;
}


// -----------------------
// UDP socket
// -----------------------

struct UdpSocket {
    fd: i64;
}


// -----------------------
// helpers
// -----------------------

fun htons(x: i16) -> i16 {
    return ((x & 255) << 8) | ((x >> 8) & 255);
}

fun htonl(x: i32) -> i32 {
    return ((x & 0x000000FF) << 24)
         | ((x & 0x0000FF00) << 8)
         | ((x & 0x00FF0000) >> 8)
         | ((x & 0xFF000000) >> 24);
}

fun _to_sockaddr(addr: UdpAddr) -> SockAddrIn {
    return SockAddrIn {
        family: 2,
        port: addr.port,
        addr: addr.ip,
        zero: [0,0,0,0,0,0,0,0]
    };
}


// -----------------------
// socket lifecycle
// -----------------------

fun udp_bind(port: i16) -> UdpSocket {
    let fd: i64 = socket(
        2,
        2,
        17
    );

    let addr: SockAddrIn = SockAddrIn {
        family: 2,
        port: htons(port),
        addr: 0,
        zero: [0,0,0,0,0,0,0,0]
    };

    bind(fd, &addr, 16);

    return UdpSocket { fd: fd };
}

fun udp_close(sock: UdpSocket) {
    shutdown(sock.fd, 2);
    close(sock.fd);
}


// -----------------------
// send / recv
// -----------------------

fun udp_send_to(
    sock: UdpSocket,
    addr: UdpAddr,
    buf: ptr<u8>,
    len: i64
) -> i64 {
    let sa: SockAddrIn = _to_sockaddr(addr);
    return sendto(
        sock.fd,
        buf,
        len,
        0,
        &sa,
        16
    );
}

fun udp_recv_from(
    sock: UdpSocket,
    buf: ptr<u8>,
    len: i64,
    src: ptr<UdpAddr>
) -> i64 {
    var sa: SockAddrIn;
    var salen: i32 = 16;

    let n: i64 = recvfrom(
        sock.fd,
        buf,
        len,
        0,
        &sa,
        &salen
    );

    deref src = UdpAddr {
        ip: sa.addr,
        port: sa.port
    };

    return n;
}
