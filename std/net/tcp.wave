// This file is part of the Wave language project.
// Copyright (c) 2024-2026 Wave Foundation
// Copyright (c) 2024-2026 LunaStev and contributors
//
// This Source Code Form is subject to the terms of the
// Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file,
// You can obtain one at https://mozilla.org/MPL/2.0/.
//
// SPDX-License-Identifier: MPL-2.0

// =======================================================
// TCP networking for Wave
// =======================================================
//
// Stream-based TCP API built on top of
// std::sys::linux::socket
//
// Blocking, minimal, synchronous TCP abstraction.
// =======================================================

import("std::sys::linux::socket");
import("std::sys::linux::fs");


// -----------------------
// IPv4 address
// -----------------------

struct TcpAddr {
    ip: i32;     // network byte order
    port: i16;   // network byte order
}


// sockaddr_in (internal)
struct SockAddrIn {
    family: i16;        // AF_INET
    port: i16;
    addr: i32;
    zero: array<u8, 8>;
}


// -----------------------
// TCP types
// -----------------------

struct TcpListener {
    fd: i64;
}

struct TcpStream {
    fd: i64;
}


// -----------------------
// helpers
// -----------------------

fun htons(x: i16) -> i16 {
    return ((x & 255) << 8) | ((x >> 8) & 255);
}

fun htonl(x: i32) -> i32 {
    return ((x & 0x000000FF) << 24)
         | ((x & 0x0000FF00) << 8)
         | ((x & 0x00FF0000) >> 8)
         | ((x & 0xFF000000) >> 24);
}

fun _to_sockaddr(addr: TcpAddr) -> SockAddrIn {
    return SockAddrIn {
        family: 2,
        port: addr.port,
        addr: addr.ip,
        zero: [0,0,0,0,0,0,0,0]
    };
}


// -----------------------
// listener
// -----------------------

fun tcp_bind(port: i16) -> TcpListener {
    let fd: i64 = socket(
        2,
        1,
        6
    );

    let addr: SockAddrIn = SockAddrIn {
        family: 2,
        port: htons(port),
        addr: 0,
        zero: [0,0,0,0,0,0,0,0]
    };

    bind(fd, &addr, 16);
    listen(fd, 128);

    return TcpListener { fd: fd };
}

fun tcp_accept(listener: TcpListener) -> TcpStream {
    let fd: i64 = accept(listener.fd, 0, 0);
    return TcpStream { fd: fd };
}

fun tcp_close_listener(listener: TcpListener) {
    shutdown(listener.fd, 2);
    close(listener.fd);
}


// -----------------------
// stream (server + client common)
// -----------------------

fun tcp_connect(addr: TcpAddr) -> TcpStream {
    let fd: i64 = socket(
        2,
        1,
        6
    );

    let sa: SockAddrIn = _to_sockaddr(addr);
    connect(fd, &sa, 16);

    return TcpStream { fd: fd };
}

fun tcp_read(stream: TcpStream, buf: ptr<u8>, len: i64) -> i64 {
    return recv(stream.fd, buf, len, 0);
}

fun tcp_write(stream: TcpStream, buf: ptr<u8>, len: i64) -> i64 {
    return send(stream.fd, buf, len, 0);
}

fun tcp_close(stream: TcpStream) {
    shutdown(stream.fd, 2);
    close(stream.fd);
}
