// =======================================================
// TCP networking for Wave
// =======================================================
//
// Stream-based TCP API built on top of
// std::sys::linux::socket
//
// Blocking, minimal, synchronous TCP abstraction.
// =======================================================

import("std::sys::linux::socket");


// -----------------------
// IPv4 address
// -----------------------

struct TcpAddr {
    ip: i32;     // network byte order
    port: i16;   // network byte order
}


// sockaddr_in (internal)
struct SockAddrIn {
    family: i16;        // AF_INET
    port: i16;
    addr: i32;
    zero: array<u8, 8>;
}


// -----------------------
// TCP types
// -----------------------

struct TcpListener {
    fd: i64;
}

struct TcpStream {
    fd: i64;
}


// -----------------------
// helpers
// -----------------------

fun htons(x: i16) -> i16 {
    var a: i32 = x;
    return ((a & 255) << 8) | ((a >> 8) & 255);
}

fun htonl(x: i32) -> i32 {
    return ((x & 0x000000FF) << 24)
         | ((x & 0x0000FF00) << 8)
         | ((x & 0x00FF0000) >> 8)
         | ((x & 0xFF000000) >> 24);
}

fun _to_sockaddr(addr: TcpAddr) -> SockAddrIn {
    return SockAddrIn {
        family: socket.AF_INET,
        port: addr.port,
        addr: addr.ip,
        zero: [0,0,0,0,0,0,0,0]
    };
}


// -----------------------
// listener
// -----------------------

fun tcp_bind(port: i16) -> TcpListener {
    let fd: i64 = socket.socket(
        socket.AF_INET,
        socket.SOCK_STREAM,
        socket.IPPROTO_TCP
    );

    let addr: SockAddrIn = SockAddrIn {
        family: socket.AF_INET,
        port: htons(port),
        addr: 0,
        zero: [0,0,0,0,0,0,0,0]
    };

    socket.bind(fd, &addr, 16);
    socket.listen(fd, 128);

    return TcpListener { fd: fd };
}

fun tcp_accept(listener: TcpListener) -> TcpStream {
    let fd: i64 = socket.accept(listener.fd, 0, 0);
    return TcpStream { fd: fd };
}

fun tcp_close_listener(listener: TcpListener) {
    socket.shutdown(listener.fd, 2);
}


// -----------------------
// stream (server + client common)
// -----------------------

fun tcp_connect(addr: TcpAddr) -> TcpStream {
    let fd: i64 = socket.socket(
        socket.AF_INET,
        socket.SOCK_STREAM,
        socket.IPPROTO_TCP
    );

    let sa: i64 = _to_sockaddr(addr);
    socket.connect(fd, &sa, 16);

    return TcpStream { fd: fd };
}

fun tcp_read(stream: TcpStream, buf: ptr<u8>, len: i64) -> i64 {
    return socket.recv(stream.fd, buf, len, 0);
}

fun tcp_write(stream: TcpStream, buf: ptr<u8>, len: i64) -> i64 {
    return socket.send(stream.fd, buf, len, 0);
}

fun tcp_close(stream: TcpStream) {
    socket.shutdown(stream.fd, 2);
}
