fun check_i32(label: str, got: i32, expected: i32) -> i32 {
    var result: i32 = 0;
    if (got == expected) {
        println("[OK] {} => {}", label, got);
        result = 1;
    } else {
        println("[FAIL] {} => got {}, expected {}", label, got, expected);
        result = 0;
    }
    return result;
}

fun test_basic_implicit_typed() -> i32 {
    var sum: i32 = 0;
    for (i :i32 = 1; i <= 5; i += 1) {
        sum += i;
    }
    return check_i32("implicit typed init (1..5 sum)", sum, 15);
}

fun test_var_initializer() -> i32 {
    var sum: i32 = 0;
    for (var i: i32 = 0; i <= 4; i += 1) {
        sum += i;
    }
    return check_i32("var init (0..4 sum)", sum, 10);
}

fun test_let_mut_initializer() -> i32 {
    var sum: i32 = 0;
    for (let mut i: i32 = 0; i < 4; i += 1) {
        sum += i;
    }
    return check_i32("let mut init (0..3 sum)", sum, 6);
}

fun test_expression_initializer() -> i32 {
    var i: i32 = 99;
    var sum: i32 = 0;

    for (i = 3; i <= 5; i += 1) {
        sum += i;
    }

    var ok: i32 = 0;
    ok += check_i32("expression init (3..5 sum)", sum, 12);
    ok += check_i32("expression init updates outer i", i, 6);
    return ok;
}

fun test_continue_behavior() -> i32 {
    var sum: i32 = 0;

    for (i :i32 = 0; i <= 6; i += 1) {
        if (i % 2 == 0) {
            continue;
        }
        sum += i;
    }

    return check_i32("continue skips even numbers", sum, 9);
}

fun test_break_behavior() -> i32 {
    var count: i32 = 0;

    for (i :i32 = 0; i < 10; i += 1) {
        if (i == 4) {
            break;
        }
        count += 1;
    }

    return check_i32("break exits at i == 4", count, 4);
}

fun test_nested_for() -> i32 {
    var outer_count: i32 = 0;
    var inner_count: i32 = 0;

    for (i :i32 = 0; i < 3; i += 1) {
        outer_count += 1;

        for (j :i32 = 0; j < 5; j += 1) {
            if (j == 2) {
                break;
            }
            inner_count += 1;
        }
    }

    var ok: i32 = 0;
    ok += check_i32("nested outer iterations", outer_count, 3);
    ok += check_i32("nested inner iterations with break", inner_count, 6);
    return ok;
}

fun test_step_increment() -> i32 {
    var sum: i32 = 0;

    for (i :i32 = 0; i <= 10; i += 2) {
        sum += i;
    }

    return check_i32("step increment += 2", sum, 30);
}

fun test_scope_shadowing() -> i32 {
    var i: i32 = 77;
    var inner_sum: i32 = 0;

    for (i :i32 = 0; i < 3; i += 1) {
        inner_sum += i;
    }

    var ok: i32 = 0;
    ok += check_i32("for shadowed i sum", inner_sum, 3);
    ok += check_i32("outer i preserved after for", i, 77);
    return ok;
}

fun main() {
    println("=== TEST 82: FOR LOOP COVERAGE START ===");

    var passed: i32 = 0;

    passed += test_basic_implicit_typed();
    passed += test_var_initializer();
    passed += test_let_mut_initializer();
    passed += test_expression_initializer();
    passed += test_continue_behavior();
    passed += test_break_behavior();
    passed += test_nested_for();
    passed += test_step_increment();
    passed += test_scope_shadowing();

    var expected_checks: i32 = 12;
    println("passed checks = {}", passed);
    println("expected checks = {}", expected_checks);
    println("=== TEST 82: FOR LOOP COVERAGE END ===");
}
